# 基于全连接网络的小麦多指标分析

# coding:utf-8
# 0导入模块，生成模拟数据集。
import tensorflow as tf
import numpy as np

# BATCH_SIZE = 8
# SEED = 23455
#
# # 基于seed产生随机数
# rdm = np.random.RandomState(SEED)
# # 随机数返回32行2列的矩阵 表示32组 体积和重量 作为输入数据集
# X = rdm.rand(32, 2)
# # 从X这个32行2列的矩阵中 取出一行 判断如果和小于1 给Y赋值1 如果和不小于1 给Y赋值0
# # 作为输入数据集的标签（正确答案）
# Y_ = [[int(x0 + x1 < 1)] for (x0, x1) in X]


BATCH_SIZE = 6

X = [[17, 375, 3950, 25.5, 90, 0.272, 62, 2.7, 1],
     [20, 420, 3750, 27.5, 92, 0.28, 53, 2.6, 1],
     [21.5, 435, 3500, 28, 91.5, 0.285, 54, 2.65, 1],
     [21, 450, 3450, 28, 90.5, 0.287, 50, 2.9, 1],
     [22, 470, 3050, 29, 86, 0.29, 49, 3.25, 1],
     [24, 485, 3000, 36, 81, 0.282, 48, 3.45, 1],
     [27.5, 495, 2800, 40.5, 75, 0.285, 47, 3.6, 1],
     [29.5, 510, 2600, 41, 66, 0.28, 46, 3.7, 1],
     [17, 365, 4100, 28.5, 92, 0.27, 61, 2.9, 2],
     [20, 400, 4050, 29, 93, 0.275, 60, 2.85, 2],
     [22, 410, 3950, 30, 91, 0.28, 60, 2.9, 2],
     [24, 440, 3650, 36.5, 91.5, 0.283, 56, 2.8, 2],
     [25, 455, 3450, 38, 86, 0.29, 55, 2.95, 2],
     [25.5, 490, 3300, 39.5, 84, 0.285, 55, 3.2, 2],
     [28, 500, 3150, 43, 81, 0.286, 53, 3.3, 2],
     [29, 510, 2250, 47, 74, 0.295, 52, 3.4, 2],
     [16.5, 390, 3900, 31, 89, 0.275, 26, 3.2, 3],
     [20.5, 480, 2950, 41.5, 94, 0.272, 25, 3.25, 3],
     [22.5, 500, 2900, 44, 91, 0.275, 24, 3.3, 3],
     [25.5, 520, 2850, 48, 90.5, 0.28, 23, 3.45, 3],
     [26, 545, 2800, 50.5, 92, 0.283, 22, 3.35, 3],
     [27, 570, 2700, 52.5, 88, 0.28, 23.5, 3.55, 3],
     [28, 580, 2600, 54.5, 82, 0.278, 22, 3.6, 3],
     [29.5, 590, 2400, 58, 79, 0.275, 21, 3.7, 3]]

'''
# 训练集数据
X = [[17, 375, 3950, 25.5, 90, 0.272, 62, 2.7, 1],
     [20, 420, 3750, 27.5, 92, 0.28, 53, 2.6, 1],
     [21.5, 435, 3500, 28, 91.5, 0.285, 54, 2.65, 1],
     [21, 450, 3450, 28, 90.5, 0.287, 50, 2.9, 1],
     [22, 470, 3050, 29, 86, 0.29, 49, 3.25, 1],
     [24, 485, 3000, 36, 81, 0.282, 48, 3.45, 1],
     [27.5, 495, 2800, 40.5, 75, 0.285, 47, 3.6, 1],
     [29.5, 510, 2600, 41, 66, 0.28, 46, 3.7, 1],
     [17, 365, 4100, 28.5, 92, 0.27, 61, 2.9, 2],
     [20, 400, 4050, 29, 93, 0.275, 60, 2.85, 2],
     [22, 410, 3950, 30, 91, 0.28, 60, 2.9, 2],
     [24, 440, 3650, 36.5, 91.5, 0.283, 56, 2.8, 2],
     [25, 455, 3450, 38, 86, 0.29, 55, 2.95, 2],
     [25.5, 490, 3300, 39.5, 84, 0.285, 55, 3.2, 2],
     [28, 500, 3150, 43, 81, 0.286, 53, 3.3, 2],
     [29, 510, 2250, 47, 74, 0.295, 52, 3.4, 2],
     [16.5, 390, 3900, 31, 89, 0.275, 26, 3.2, 3],
     [20.5, 480, 2950, 41.5, 94, 0.272, 25, 3.25, 3],
     [22.5, 500, 2900, 44, 91, 0.275, 24, 3.3, 3],
     [25.5, 520, 2850, 48, 90.5, 0.28, 23, 3.45, 3],
     [26, 545, 2800, 50.5, 92, 0.283, 22, 3.35, 3],
     [27, 570, 2700, 52.5, 88, 0.28, 23.5, 3.55, 3],
     [28, 580, 2600, 54.5, 82, 0.278, 22, 3.6, 3],
     [29.5, 590, 2400, 58, 79, 0.275, 21, 3.7, 3]]
'''

'''
# 强筋小麦
0	17	375	3950	25.5	90	0.272	62	2.7	1	m0
30	20	420	3750	27.5	92	0.28	53	2.6	1	m1
60	21.5	435	3500	28	91.5	0.285	54	2.65	1	m2
90	21	450	3450	28	90.5	0.287	50	2.9	1	m3
120	22	470	3050	29	86	0.29	49	3.25	1	m4
150	24	485	3000	36	81	0.282	48	3.45	1	m5
180	27.5	495	2800	40.5	75	0.285	47	3.6	1	m6
210	29.5	510	2600	41	66	0.28	46	3.7	1	m7
'''
'''
# 中筋小麦
0	17	365	4100	28.5	92	0.27	61	2.9	2	m0
30	20	400	4050	29	93	0.275	60	2.85	2	m1
60	22	410	3950	30	91	0.28	60	2.9	2	m2
90	24	440	3650	36.5	91.5	0.283	56	2.8	2	m3
120	25	455	3450	38	86	0.29	55	2.95	2	m4
150	25.5	490	3300	39.5	84	0.285	55	3.2	2	m5
180	28	500	3150	43	81	0.286	53	3.3	2	m6
210	29	510	2250	47	74	0.295	52	3.4	2	m7
'''
'''
# 弱筋小麦
0	16.5	390	3900	31	89	0.275	26	3.2	3	m0
30	20.5	480	2950	41.5	94	0.272	25	3.25	3	m1
60	22.5	500	2900	44	91	0.275	24	3.3	3	m2
90	25.5	520	2850	48	90.5	0.28	23	3.45	3	m3
120	26	545	2800	50.5	92	0.283	22	3.35	3	m4
150	27	570	2700	52.5	88	0.28	23.5	3.55	3	m5
180	28	580	2600	54.5	82	0.278	22	3.6	3	m6
210	29.5	590	2400	58	79	0.275	21	3.7	3	m7
'''

Y_ = [[0], [1], [2], [3], [4], [5], [6], [7],
      [0], [1], [2], [3], [4], [5], [6], [7],
      [0], [1], [2], [3], [4], [5], [6], [7]]

# X = np.array(X1)
X -= np.mean(X, axis=0)
X /= np.std(X, axis=0)

print("X:\n", X, type(X))
print("Y_:\n", Y_, type(Y_))

# 1定义神经网络的输入、参数和输出,定义前向传播过程。
x = tf.placeholder(tf.float32, shape=(None, 9))
y_ = tf.placeholder(tf.float32, shape=(None, 1))

w1 = tf.Variable(tf.random_normal([9, 10], stddev=1, seed=1))
w2 = tf.Variable(tf.random_normal([10, 1], stddev=1, seed=1))

a = tf.matmul(x, w1)
y = tf.matmul(a, w2)

# 2定义损失函数及反向传播方法。
loss_mse = tf.reduce_mean(tf.square(y - y_))
train_step = tf.train.GradientDescentOptimizer(0.001).minimize(loss_mse)
# train_step = tf.train.MomentumOptimizer(0.001,0.9).minimize(loss_mse)
# train_step = tf.train.AdamOptimizer(0.001).minimize(loss_mse)

# 3生成会话，训练STEPS轮
with tf.Session() as sess:
    init_op = tf.global_variables_initializer()
    sess.run(init_op)
    # 输出目前（未经训练）的参数取值。
    print("w1:\n", sess.run(w1))
    print("w2:\n", sess.run(w2))

    # 训练模型。
    STEPS = 10000
    for i in range(STEPS):
        start = (i * BATCH_SIZE) % 24
        end = start + BATCH_SIZE
        sess.run(train_step, feed_dict={x: X[start:end], y_: Y_[start:end]})
        if i % 100 == 0:
            total_loss = sess.run(loss_mse, feed_dict={x: X, y_: Y_})
            print("After %d training step(s), loss_mse on all data is %g" % (i, total_loss))

    # 输出训练后的参数取值。
    print("w1:\n", sess.run(w1))
    print("w2:\n", sess.run(w2))

    # xx = [[17, 375, 3950, 25.5, 90, 0.272, 62, 2.7, 1],
    #       [20, 420, 3750, 27.5, 92, 0.28, 53, 2.6, 1]]
    #
    # xx -= np.mean(xx, axis=0)
    # xx /= np.std(xx, axis=0)

    # xx = [[-1.70342721, -1.61637347, 1.36109557, -1.39023063, 0.53401414, -1.44929915, 1.22733975, -1.46512031, -1.22474487],
    #       [-0.93927295, -0.88443077, 0.99198491, -1.17838596, 0.81882168, -0.1550413, 0.62551141, -1.76437893, -1.22474487]]

    xx = [[-1.70342721, -1.61637347, 1.36109557, -1.39023063, 0.53401414, -1.44929915, 1.22733975, -1.46512031,
           -1.22474487],
          [-0.93927295, -0.88443077, 0.99198491, -1.17838596, 0.81882168, -0.1550413, 0.62551141, -1.76437893,
           - 1.22474487],
          [-0.55719582, -0.64044987, 0.53059658, -1.12542479, 0.7476198, 0.65386985, 0.69238122, -1.61474962,
           -1.22474487],
          [-0.68455486, -0.39646896, 0.43831891, -1.12542479, 0.60521603, 0.97743431, 0.42490196, -0.86660308,
           -1.22474487],
          [-0.42983677, -0.0711611, -0.29990241, -1.01950246, -0.03560094, 1.462781, 0.35803214, 0.18080208,
           -1.22474487],
          [0.0795994, 0.17281981, -0.39218008, -0.27804613, -0.7476198, 0.16852316, 0.29116233, 0.77931931,
           -1.22474487],
          [0.97111271, 0.33547374, -0.76129074, 0.19860438, -1.60204242, 0.65386985, 0.22429251, 1.22820724,
           -1.22474487],
          [1.48054889, 0.57945464, -1.13040141, 0.25156554, -2.88367636, - 0.1550413, 0.15742269, 1.52746586,
           -1.22474487]]
    print('xx:', xx)

    aa = tf.matmul(xx, w1)
    yy = tf.matmul(aa, w2)
    print('判定值：', yy.eval() + 3.5)
